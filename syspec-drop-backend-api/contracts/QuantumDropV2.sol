// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title QuantumDropV2
 * @dev Quantum-resistant dead-drop file sharing with metadata burn
 * 
 * Security Features:
 * - Passphrase-based claim verification
 * - One-time access with automatic metadata destruction
 * - Quantum-resistant encryption metadata storage
 * - IPFS integration for decentralized storage
 * 
 * Compliance: ISO 27001, NIST FIPS 203/204
 */
contract QuantumDropV2 {
    
    // ============ Structs ============
    
    struct Drop {
        string ipfsHash;              // IPFS CID (encrypted file location)
        string encryptedSymKey;       // AES-256 key wrapped with ML-KEM-768
        bytes32 passphraseHash;       // keccak256(passphrase) - never store plaintext
        address owner;                // Uploader address
        uint256 createdAt;            // Timestamp (block.timestamp)
        bool isActive;                // False after claim (prevents re-access)
        bool claimed;                 // True after successful claim
    }
    
    // ============ State Variables ============
    
    mapping(string => Drop) private drops;
    mapping(string => mapping(address => bool)) private claimAttempts;
    
    uint256 public totalDrops;
    uint256 public totalClaimed;
    
    // ============ Events ============
    
    event DropCreated(
        string indexed dropId,
        string ipfsHash,
        address indexed owner,
        uint256 createdAt
    );
    
    event DropClaimed(
        string indexed dropId,
        address indexed claimer,
        uint256 claimedAt
    );
    
    event MetadataBurned(
        string indexed dropId,
        uint256 burnedAt
    );
    
    event ClaimAttemptFailed(
        string indexed dropId,
        address indexed claimer,
        string reason
    );
    
    // ============ Modifiers ============
    
    modifier dropExists(string memory dropId) {
        require(drops[dropId].owner != address(0), "Drop does not exist");
        _;
    }
    
    modifier dropActive(string memory dropId) {
        require(drops[dropId].isActive, "Drop is inactive");
        require(!drops[dropId].claimed, "Drop already claimed");
        _;
    }
    
    // ============ Core Functions ============
    
    /**
     * @notice Create a new quantum-secure drop
     * @param dropId Unique identifier (UUID generated by server)
     * @param ipfsHash IPFS CID of encrypted file
     * @param encryptedSymKey AES-256 key wrapped with ML-KEM-768 public key
     * @param passphraseHash keccak256(passphrase) - NEVER pass plaintext
     */
    function createDrop(
        string memory dropId,
        string memory ipfsHash,
        string memory encryptedSymKey,
        bytes32 passphraseHash
    ) external {
        require(bytes(dropId).length > 0, "Drop ID required");
        require(bytes(ipfsHash).length > 0, "IPFS hash required");
        require(bytes(encryptedSymKey).length > 0, "Encrypted key required");
        require(passphraseHash != bytes32(0), "Passphrase hash required");
        require(drops[dropId].owner == address(0), "Drop already exists");
        
        // Store drop metadata
        drops[dropId] = Drop({
            ipfsHash: ipfsHash,
            encryptedSymKey: encryptedSymKey,
            passphraseHash: passphraseHash,
            owner: msg.sender,
            createdAt: block.timestamp,
            isActive: true,
            claimed: false
        });
        
        totalDrops++;
        
        emit DropCreated(dropId, ipfsHash, msg.sender, block.timestamp);
    }
    
    /**
     * @notice Claim a drop with passphrase verification
     * @dev Verifies passphrase, releases metadata, then burns sensitive data
     * @param dropId The drop to claim
     * @param passphraseHash keccak256(passphrase) for verification
     * @return ipfsHash IPFS CID for file retrieval
     * @return encryptedSymKey Wrapped AES key for decryption
     */
    function claimDrop(
        string memory dropId,
        bytes32 passphraseHash
    ) 
        external 
        dropExists(dropId)
        dropActive(dropId)
        returns (string memory ipfsHash, string memory encryptedSymKey)
    {
        Drop storage drop = drops[dropId];
        
        // Step 1: Track claim attempt
        claimAttempts[dropId][msg.sender] = true;
        
        // Step 2: Verify passphrase hash matches
        if (drop.passphraseHash != passphraseHash) {
            emit ClaimAttemptFailed(dropId, msg.sender, "Invalid passphrase");
            revert("Invalid passphrase");
        }
        
        // Step 3: Return metadata (caller can now decrypt file)
        ipfsHash = drop.ipfsHash;
        encryptedSymKey = drop.encryptedSymKey;
        
        // Step 4: Mark as claimed BEFORE burning (reentrancy protection)
        drop.claimed = true;
        drop.isActive = false;
        totalClaimed++;
        
        emit DropClaimed(dropId, msg.sender, block.timestamp);
        
        // Step 5: Burn sensitive metadata (one-time access enforcement)
        delete drop.encryptedSymKey;
        
        emit MetadataBurned(dropId, block.timestamp);
        
        return (ipfsHash, encryptedSymKey);
    }
    
    // ============ Read-Only Functions ============
    
    /**
     * @notice Get drop status (privacy-preserving)
     * @dev Does NOT reveal passphraseHash or encryptedSymKey
     * @param dropId Drop identifier
     * @return ipfsHash IPFS CID (public)
     * @return owner Creator address
     * @return createdAt Timestamp
     * @return isActive Drop status
     * @return claimed Claim status
     */
    function getDrop(string memory dropId) 
        external 
        view 
        dropExists(dropId)
        returns (
            string memory ipfsHash,
            address owner,
            uint256 createdAt,
            bool isActive,
            bool claimed
        )
    {
        Drop memory drop = drops[dropId];
        return (
            drop.ipfsHash,
            drop.owner,
            drop.createdAt,
            drop.isActive,
            drop.claimed
        );
    }
    
    /**
     * @notice Check if drop is valid and claimable
     * @param dropId Drop identifier
     * @return bool True if active and unclaimed
     */
    function isValidDrop(string memory dropId) external view returns (bool) {
        if (drops[dropId].owner == address(0)) return false;
        return drops[dropId].isActive && !drops[dropId].claimed;
    }
    
    /**
     * @notice Check if address has attempted to claim a drop
     * @param dropId Drop identifier
     * @param claimer Address to check
     * @return bool True if claim was attempted
     */
    function hasClaimAttempt(string memory dropId, address claimer) 
        external 
        view 
        returns (bool) 
    {
        return claimAttempts[dropId][claimer];
    }
    
    /**
     * @notice Get passphrase hash for verification (use with caution)
     * @dev Only for admin/debugging - leaks partial information
     * @param dropId Drop identifier
     * @return bytes32 Passphrase hash
     */
    function getPassphraseHash(string memory dropId) 
        external 
        view 
        dropExists(dropId)
        returns (bytes32) 
    {
        return drops[dropId].passphraseHash;
    }
    
    // ============ Admin Functions ============
    
    /**
     * @notice Emergency deactivate drop (owner only)
     * @dev Does NOT burn metadata, only disables claims
     * @param dropId Drop to deactivate
     */
    function deactivateDrop(string memory dropId) 
        external 
        dropExists(dropId)
    {
        Drop storage drop = drops[dropId];
        require(drop.owner == msg.sender, "Not drop owner");
        require(drop.isActive, "Already inactive");
        
        drop.isActive = false;
    }
    
    /**
     * @notice Get contract statistics
     * @return totalDropsCreated Total drops ever created
     * @return totalDropsClaimed Total drops successfully claimed
     * @return activeDrops Currently active (unclaimed) drops
     */
    function getStats() 
        external 
        view 
        returns (
            uint256 totalDropsCreated,
            uint256 totalDropsClaimed,
            uint256 activeDrops
        )
    {
        return (totalDrops, totalClaimed, totalDrops - totalClaimed);
    }
}
